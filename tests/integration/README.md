# Integration Testing for PSWSMan

As testing PSWSMan requires a Windows host to talk to it is hard to test all the various edge cases and scenarios through CI.
This document is designed to walk through the integration test setup to run the full suite of tests against on the current host.
The test environment to create the WinRM server and domain environment is provided by [wsman-environment](https://github.com/jborean93/wsman-environment).

The `wsman-environment` repo will spin up a few virtual machines with the following:

+ A domain controller under `dc.wsman.env`
+ A target WSMan server under `test.wsman.env`
+ A target Windows server for testing things like double hop authentication or running the module on a domain joined Windows host
+ A Linux host that has a proxy server for testing proxy configurations

The target WSMan server has the following features

+ All auth methods enabled; `Basic`, `Certificate`, `Negotiate`, `CredSSP`
+ A local admin account for testing local account access
+ A HTTPS listener signed by a certificate authority that `wsman-environment` provides
+ Multiple WinRM listeners that cover:
    + HTTPS listeners signed by a CA provided by `wsman-environment`
    + Multiple signing algorithms, `sha1`, `sha256`, `sha512`, etc
    + Ports blocked by direct access for proxy verification
+ A Just Enough Administration endpoint

To set up this environment you will need both `Vagrant` and `Ansible` to be installed.
Once installed run the following:

```bash
git clone https://github.com/jborean93/wsman-environment.git
cd wsman-environment
ansible-galaxy collection install -r requirements.yml

vagrant up

ansible-playbook main.yml -vv
```

This may take some time to complete and if the Ansible playbook fails, running it again should clear out any errors.
Once setup, run `pwsh -File tests/integration/generate_settings.ps1 ~/wsman-environment` to generate the `test.settings.json` file which can be used by the test suite.

On macOS, the CA certificate generated by `wsman-environment` needs to be loaded in the system trust store.
This can be done using the following commands to load the CA cert at the `~/ca.pem` path.

```bash
sudo security authorizationdb read com.apple.trust-settings.admin > rights
sudo security authorizationdb write com.apple.trust-settings.admin allow
sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ~/ca.pem
sudo security authorizationdb write com.apple.trust-settings.admin < rights
```

Once the tests are completed the certificate can be removed from the `Keychain Access` application.

## Exchange Online

One scenario that can be tested is to test connections with Exchange Online and modern authentication.
The following code will set up a principal in your Microsoft 365 account that is set up for modern auth for testing.

```powershell
# Make sure we are in the `tests/integration` folder
cd tests/integration

# Run it in this container to access Azure Graph in PowerSHellazure-cli
docker run -it -v "$( pwd ):/app:Z" -w /app mcr.microsoft.com/microsoftgraph/powershell:latest

# Generates the certificate used for exchange authentication
$certPassword = [Guid]::NewGuid().ToString()
openssl @(
    'req', '-x509'
    '-newkey', 'rsa:2048'
    '-keyout', 'exchange-key.pem'
    '-passout', "pass:$certPassword"
    '-out', 'exchange-cert.pem'
    '-days', '1'
    '-subj', '/CN=ExchangeTest'

)
openssl @(
    'pkcs12', '-export'
    '-out', 'exchange-cert.pfx'
    '-passout', "pass:$certPassword"
    '-inkey', 'exchange-key.pem'
    '-passin', "pass:$certPassword"
    '-in', 'exchange-cert.pem'
)
chmod 644 exchange-cert.pfx
$cert = Get-PfxCertificate -FilePath exchange-cert.pem

Remove-Item -Path exchange-key.pem
Remove-Item -Path exchange-cert.pem

# Open the link and authenticate with a user with an O365 subscription
# Note: This requires some manual interaction
$connectParams = @{
    ContextScope = 'Process'
    Scopes = @(
        'Application.ReadWrite.All'
        'AppRoleAssignment.ReadWrite.All'
        'RoleManagement.ReadWrite.Directory'
    )
    UseDeviceAuthentication = $true
}
Connect-MgGraph @connectParams

$exchangeManageAsAppId = "dc50a0fb-09a3-484d-be87-e023b12c6440"
$exoId = '00000002-0000-0ff1-ce00-000000000000'
$exoResourceId = (Get-MgServicePrincipal -Filter "AppId eq '$exoId'").Id

$newAppParams = @{
    DisplayName = 'PSWSManTest'
    RequiredResourceAccess = @(
        @{
            ResourceAppId = $exoId
            ResourceAccess = @(
                @{
                    Id = $exchangeManageAsAppId
                    Type = 'Role'
                }
            )
        },
        @{
            ResourceAppId = '00000003-0000-0000-c000-000000000000'
            ResourceAccess = @(
                @{
                    Id = 'e1fe6dd8-ba31-4d61-89e7-88639da4683d'
                    Type = 'Scope'
                }
            )
        }
    )
    KeyCredentials = @(
        @{
            Type = 'AsymmetricX509Cert'
            Usage = 'Verify'
            Key = $cert.RawData
        }
    )
}
$azApp = New-MgApplication @newAppParams
$azSP = New-MgServicePrincipal -BodyParameter @{AppId = $azApp.AppId}

$grantParams = @{
    ServicePrincipalId = $azSP.Id
    PrincipalId = $azSP.Id
    AppRoleId = $exchangeManageAsAppId
    ResourceId = $exoResourceId
}
$null = New-MgServicePrincipalAppRoleAssignment @grantParams

$clientSecret = Add-MgApplicationPassword -ApplicationId $azApp.Id -PasswordCredential @{
    DisplayName = 'Test Secret'
    EndDateTime = (Get-Date).AddDays(1)
}

$exchangeRole = Get-MgDirectoryRole -Filter "displayName eq 'Exchange Administrator'"
$roleAssignmentParams = @{
    # v1.0 doesn't return service principals
    # https://github.com/microsoftgraph/msgraph-sdk-powershell/issues/880
    Uri = "beta/directoryRoles/$($exchangeRole.Id)/members"
    Method = 'GET'
}
$roleAssignment = (Invoke-MgGraphRequest @roleAssignmentParams).value |
    Where-Object { $_.id -eq $azSP.Id } |
    Select-Object -First 1
if (-not $roleAssignment) {
    New-MgDirectoryRoleMemberByRef -DirectoryRoleId $exchangeRole.Id -BodyParameter @{
        "@odata.id" = "https://graph.microsoft.com/v1.0/directoryObjects/$($azSP.Id)"
    }
}

@{
    tenant_id = (Get-MgContext).TenantId
    organization = (Get-MgDomain).Id
    app_id = $azApp.AppId
    client_secret = $clientSecret.SecretText
    cert_password = $certPassword
} | ConvertTo-Json | Set-Content -Path exchange.json

Disconnect-MgGraph
```

Then place the following in `test.settings.json`:

```json
{
    ...
    "data": {
        ...
        "exchange_online": {
            "organization": "Located in exchange.json - organization",
            "app_id": "Located in exchange.json - app_id",
            "certificate_path": "path/to/exchange-cert.pfx",
            "certificate_password": "Located in exchange.json - cert_password"
        }
    }
}
```

The values are all from the `exchange.json` file generated from the steps above.
The `certificate_path` is the path to the `exchange-cert.pfx` that was also generated above.
If `certificate_path` is not set the tests for certificate authentication is skipped.
